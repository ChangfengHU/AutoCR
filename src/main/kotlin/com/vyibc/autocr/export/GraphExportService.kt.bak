package com.vyibc.autocr.export

import com.intellij.openapi.components.Service
import com.intellij.openapi.components.service
import com.intellij.openapi.project.Project
import com.vyibc.autocr.graph.CodeGraph
import com.vyibc.autocr.model.*
import com.google.gson.stream.JsonWriter
import java.io.FileWriter
import java.io.BufferedWriter
import org.slf4j.LoggerFactory
import java.io.File
import java.time.Instant
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * 图谱数据导出服务 - 优化内存使用版本
 * 负责将本地图谱数据导出为各种格式文件，使用流式处理避免内存溢出
 */
@Service(Service.Level.PROJECT)
class GraphExportService(private val project: Project) {
    private val logger = LoggerFactory.getLogger(GraphExportService::class.java)
    
    // 内存优化配置
    companion object {
        private const val NODE_BATCH_SIZE = 50 // 每批处理的节点数量
        private const val EDGE_BATCH_SIZE = 100 // 每批处理的边数量
        private const val MEMORY_CHECK_INTERVAL = 5 // 每处理多少批检查一次内存
        private const val MIN_FREE_MEMORY_MB = 50 // 最小剩余内存(MB)
        private const val FORCE_GC_THRESHOLD = 70 // 强制GC的内存使用率阈值(%)
        
        fun getInstance(project: Project): GraphExportService {
            return project.service()
        }
    }
    
    /**
     * 导出图谱数据为JSON格式 - 使用流式写入优化内存
     */
    fun exportToJson(codeGraph: CodeGraph, outputPath: String): ExportResult {
        return try {
            val startTime = System.currentTimeMillis()
            
            val outputFile = File(outputPath)
            outputFile.parentFile?.mkdirs()
            
            FileWriter(outputFile).use { fileWriter ->
                JsonWriter(fileWriter).use { writer ->
                    writer.setIndent("  ") // 设置缩进美化输出
                    
                    writer.beginObject() // 开始根对象
                    
                    // 写入元数据
                    writeMetadata(writer)
                    
                    // 获取并写入统计信息
                    val allNodes = codeGraph.getAllNodes()
                    val allEdges = codeGraph.getAllEdges()
                    writeStatistics(writer, allNodes, allEdges)
                    
                    // 分批写入节点数据
                    writeNodesInBatches(writer, allNodes)
                    
                    // 分批写入边数据
                    writeEdgesInBatches(writer, allEdges)
                    
                    writer.endObject() // 结束根对象
                }
            }
            
            val duration = System.currentTimeMillis() - startTime
            val allNodes = codeGraph.getAllNodes()
            val allEdges = codeGraph.getAllEdges()
            
            logger.info("Successfully exported graph data to: $outputPath")
            logger.info("Export statistics: {} nodes, {} edges, duration: {}ms", 
                allNodes.size, allEdges.size, duration)
            
            ExportResult(
                success = true,
                filePath = outputPath,
                totalNodes = allNodes.size,
                totalEdges = allEdges.size,
                fileSize = outputFile.length(),
                duration = duration,
                message = "图谱数据成功导出到 $outputPath"
            )
            
        } catch (e: Exception) {
            logger.error("Failed to export graph data to JSON", e)
            ExportResult(
                success = false,
                filePath = outputPath,
                totalNodes = 0,
                totalEdges = 0,
                fileSize = 0,
                duration = 0,
                message = "导出失败: ${e.message}"
            )
        } finally {
            // 强制进行垃圾回收以释放内存
            System.gc()
        }
    }
    
    /**
     * 写入元数据
     */
    private fun writeMetadata(writer: JsonWriter) {
        writer.name("metadata")
        writer.beginObject()
        writer.name("projectName").value(project.name)
        writer.name("exportTime").value(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))
        writer.name("exportVersion").value("1.0")
        writer.endObject()
    }
    
    /**
     * 写入统计信息
     */
    private fun writeStatistics(writer: JsonWriter, allNodes: List<Node>, allEdges: List<Edge>) {
        val classes = allNodes.filterIsInstance<ClassNode>()
        val methods = allNodes.filterIsInstance<MethodNode>()
        
        writer.name("statistics")
        writer.beginObject()
        
        writer.name("totalNodes").value(allNodes.size)
        writer.name("totalEdges").value(allEdges.size)
        writer.name("totalClasses").value(classes.size)
        writer.name("totalMethods").value(methods.size)
        
        // 边类型分布
        writer.name("edgeTypeDistribution")
        writer.beginObject()
        allEdges.groupBy { it.edgeType }.forEach { (type, edges) ->
            writer.name(type.name).value(edges.size)
        }
        writer.endObject()
        
        // 类块类型分布
        writer.name("classBlockTypeDistribution")
        writer.beginObject()
        classes.groupBy { it.blockType }.forEach { (type, classList) ->
            writer.name(type.name).value(classList.size)
        }
        writer.endObject()
        
        // 方法块类型分布
        writer.name("methodBlockTypeDistribution")
        writer.beginObject()
        methods.groupBy { it.blockType }.forEach { (type, methodList) ->
            writer.name(type.name).value(methodList.size)
        }
        writer.endObject()
        
        writer.endObject()
    }
    
    /**
     * 分批写入节点数据
     */
    private fun writeNodesInBatches(writer: JsonWriter, allNodes: List<Node>) {
        writer.name("nodes")
        writer.beginArray()
        
        val classes = allNodes.filterIsInstance<ClassNode>()
        val methods = allNodes.filterIsInstance<MethodNode>()
        
        // 分批处理类节点
        var batchCount = 0
        classes.chunked(NODE_BATCH_SIZE).forEach { batch ->
            batch.forEach { classNode ->
                writeClassNode(writer, classNode)
            }
            
            // 定期检查内存并清理
            if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                checkMemoryAndGC()
            }
        }
        
        // 分批处理方法节点
        methods.chunked(NODE_BATCH_SIZE).forEach { batch ->
            batch.forEach { methodNode ->
                writeMethodNode(writer, methodNode)
            }
            
            // 定期检查内存并清理
            if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                checkMemoryAndGC()
            }
        }
        
        writer.endArray()
    }
    
    /**
     * 写入类节点
     */
    private fun writeClassNode(writer: JsonWriter, classNode: ClassNode) {
        writer.beginObject()
        writer.name("id").value(classNode.id)
        writer.name("type").value("class")
        writer.name("className").value(classNode.className)
        writer.name("packageName").value(classNode.packageName)
        writer.name("blockType").value(classNode.blockType.name)
        writer.name("isInterface").value(classNode.isInterface)
        writer.name("isAbstract").value(classNode.isAbstract)
        writer.name("filePath").value(classNode.filePath)
        
        if (classNode.superClass != null) {
            writer.name("superClass").value(classNode.superClass)
        }
        
        if (classNode.implementedInterfaces.isNotEmpty()) {
            writer.name("implementedInterfaces")
            writer.beginArray()
            classNode.implementedInterfaces.forEach { writer.value(it) }
            writer.endArray()
        }
        
        if (classNode.annotations.isNotEmpty()) {
            writer.name("annotations")
            writer.beginArray()
            classNode.annotations.forEach { writer.value(it) }
            writer.endArray()
        }
        
        writer.endObject()
    }
    
    /**
     * 写入方法节点
     */
    private fun writeMethodNode(writer: JsonWriter, methodNode: MethodNode) {
        writer.beginObject()
        writer.name("id").value(methodNode.id)
        writer.name("type").value("method")
        writer.name("methodName").value(methodNode.methodName)
        writer.name("signature").value(methodNode.signature)
        writer.name("returnType").value(methodNode.returnType)
        writer.name("blockType").value(methodNode.blockType.name)
        writer.name("filePath").value(methodNode.filePath)
        writer.name("lineNumber").value(methodNode.lineNumber)
        writer.name("startLineNumber").value(methodNode.startLineNumber)
        writer.name("endLineNumber").value(methodNode.endLineNumber)
        writer.name("cyclomaticComplexity").value(methodNode.cyclomaticComplexity)
        writer.name("linesOfCode").value(methodNode.linesOfCode)
        writer.name("lastModified").value(methodNode.lastModified.toString())
        
        if (methodNode.paramTypes.isNotEmpty()) {
            writer.name("paramTypes")
            writer.beginArray()
            methodNode.paramTypes.forEach { writer.value(it) }
            writer.endArray()
        }
        
        if (methodNode.annotations.isNotEmpty()) {
            writer.name("annotations")
            writer.beginArray()
            methodNode.annotations.forEach { writer.value(it) }
            writer.endArray()
        }
        
        writer.endObject()
    }
    
    /**
     * 分批写入边数据
     */
    private fun writeEdgesInBatches(writer: JsonWriter, allEdges: List<Edge>) {
        writer.name("edges")
        writer.beginArray()
        
        var batchCount = 0
        allEdges.chunked(EDGE_BATCH_SIZE).forEach { batch ->
            batch.forEach { edge ->
                writeEdge(writer, edge)
            }
            
            // 定期检查内存并清理
            if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                checkMemoryAndGC()
            }
        }
        
        writer.endArray()
    }
    
    /**
     * 写入边数据
     */
    private fun writeEdge(writer: JsonWriter, edge: Edge) {
        writer.beginObject()
        writer.name("id").value(edge.id)
        writer.name("sourceId").value(edge.sourceId)
        writer.name("targetId").value(edge.targetId)
        writer.name("edgeType").value(edge.edgeType.name)
        
        // 根据边类型添加特定属性
        when (edge) {
            is CallsEdge -> {
                writer.name("callType").value(edge.callType)
                writer.name("lineNumber").value(edge.lineNumber)
            }
            is ContainsEdge -> {
                // 包含边的特定属性
            }
            is DataFlowEdge -> {
                // 数据流边的特定属性
            }
            is ImplementsEdge -> {
                // 实现边的特定属性
            }
            is InheritsEdge -> {
                // 继承边的特定属性
            }
        }
        
        writer.endObject()
    }
    
    /**
     * 检查内存并执行垃圾回收
     */
    private fun checkMemoryAndGC() {
        val runtime = Runtime.getRuntime()
        val maxMemory = runtime.maxMemory()
        val totalMemory = runtime.totalMemory()
        val freeMemory = runtime.freeMemory()
        val usedMemory = totalMemory - freeMemory
        val heapUsagePercent = (usedMemory * 100) / maxMemory
        
        if (heapUsagePercent >= FORCE_GC_THRESHOLD) {
            logger.debug("High memory usage detected ({}%), performing GC", heapUsagePercent)
            System.gc()
            Thread.sleep(100) // 给GC一点时间
        }
    }
    
    /**
     * 导出图谱数据为Cypher格式（用于Neo4j导入）- 使用流式写入优化内存
     */
    fun exportToCypher(codeGraph: CodeGraph, outputPath: String): ExportResult {
        return try {
            val startTime = System.currentTimeMillis()
            val outputFile = File(outputPath)
            outputFile.parentFile?.mkdirs()
            
            val writer = outputFile.bufferedWriter()
            
            writer.use { w ->
                // 写入文件头
                w.write("// AutoCR 知识图谱 Cypher 导出文件\n")
                w.write("// 项目: ${project.name}\n")
                w.write("// 导出时间: ${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}\n\n")
                
                // 清空数据库
                w.write("// 清空现有数据\n")
                w.write("MATCH (n) DETACH DELETE n;\n\n")
                
                val allNodes = codeGraph.getAllNodes()
                val allEdges = codeGraph.getAllEdges()
                
                // 分批写入类节点
                w.write("// 创建类节点\n")
                val classes = allNodes.filterIsInstance<ClassNode>()
                var batchCount = 0
                classes.chunked(NODE_BATCH_SIZE).forEach { batch ->
                    batch.forEach { classNode ->
                        writeClassNodeCypher(w, classNode)
                    }
                    w.flush() // 定期刷新缓冲区
                    
                    if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                        checkMemoryAndGC()
                    }
                }
                
                // 分批写入方法节点
                w.write("\n// 创建方法节点\n")
                val methods = allNodes.filterIsInstance<MethodNode>()
                methods.chunked(NODE_BATCH_SIZE).forEach { batch ->
                    batch.forEach { methodNode ->
                        writeMethodNodeCypher(w, methodNode)
                    }
                    w.flush() // 定期刷新缓冲区
                    
                    if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                        checkMemoryAndGC()
                    }
                }
                
                // 分批写入关系
                w.write("\n// 创建关系\n")
                allEdges.chunked(EDGE_BATCH_SIZE).forEach { batch ->
                    batch.forEach { edge ->
                        writeEdgeCypher(w, edge)
                    }
                    w.flush() // 定期刷新缓冲区
                    
                    if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                        checkMemoryAndGC()
                    }
                }
                
                // 写入索引创建语句
                w.write("\n// 创建索引\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (c:Class) ON (c.id);\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (m:Method) ON (m.id);\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (c:Class) ON (c.packageName);\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (m:Method) ON (m.methodName);\n")
            }
            
            val duration = System.currentTimeMillis() - startTime
            val allNodes = codeGraph.getAllNodes()
            val allEdges = codeGraph.getAllEdges()
            
            logger.info("Successfully exported graph data to Cypher format: $outputPath")
            
            ExportResult(
                success = true,
                filePath = outputPath,
                totalNodes = allNodes.size,
                totalEdges = allEdges.size,
                fileSize = outputFile.length(),
                duration = duration,
                message = "Cypher脚本成功导出到 $outputPath"
            )
            
        } catch (e: Exception) {
            logger.error("Failed to export graph data to Cypher format", e)
            ExportResult(
                success = false,
                filePath = outputPath,
                totalNodes = 0,
                totalEdges = 0,
                fileSize = 0,
                duration = 0,
                message = "Cypher导出失败: ${e.message}"
            )
        } finally {
            System.gc() // 清理内存
        }
    }
    
    /**
     * 写入类节点的Cypher语句
     */
    private fun writeClassNodeCypher(writer: BufferedWriter, classNode: ClassNode) {
        writer.write("CREATE (c:Class {\n")
        writer.write("  id: '${classNode.id}',\n")
        writer.write("  className: '${classNode.className}',\n")
        writer.write("  packageName: '${classNode.packageName}',\n")
        writer.write("  blockType: '${classNode.blockType.name}',\n")
        writer.write("  isInterface: ${classNode.isInterface},\n")
        writer.write("  isAbstract: ${classNode.isAbstract},\n")
        writer.write("  filePath: '${classNode.filePath}'\n")
        writer.write("});\n")
    }
    
    /**
     * 写入方法节点的Cypher语句
     */
    private fun writeMethodNodeCypher(writer: BufferedWriter, methodNode: MethodNode) {
        writer.write("CREATE (m:Method {\n")
        writer.write("  id: '${methodNode.id}',\n")
        writer.write("  methodName: '${methodNode.methodName}',\n")
        writer.write("  signature: '${methodNode.signature}',\n")
        writer.write("  returnType: '${methodNode.returnType}',\n")
        writer.write("  blockType: '${methodNode.blockType.name}',\n")
        writer.write("  filePath: '${methodNode.filePath}',\n")
        writer.write("  lineNumber: ${methodNode.lineNumber},\n")
        writer.write("  cyclomaticComplexity: ${methodNode.cyclomaticComplexity},\n")
        writer.write("  linesOfCode: ${methodNode.linesOfCode}\n")
        writer.write("});\n")
    }
    
    /**
     * 写入边的Cypher语句
     */
    private fun writeEdgeCypher(writer: BufferedWriter, edge: Edge) {
        val relationshipType = when (edge.edgeType) {
            EdgeType.CALLS -> "CALLS"
            EdgeType.INHERITS -> "INHERITS"
            EdgeType.IMPLEMENTS -> "IMPLEMENTS"
            EdgeType.CONTAINS -> "CONTAINS"
            EdgeType.DATA_FLOW -> "DATA_FLOW"
        }
        
        writer.write("MATCH (source {id: '${edge.sourceId}'}), (target {id: '${edge.targetId}'})\n")
        writer.write("CREATE (source)-[:$relationshipType")
        
        // 添加关系属性
        when (edge) {
            is CallsEdge -> {
                writer.write(" {callType: '${edge.callType}', lineNumber: ${edge.lineNumber}}")
            }
            is ContainsEdge -> {
                // 包含边属性
            }
            is DataFlowEdge -> {
                // 数据流边属性
            }
            is ImplementsEdge -> {
                // 实现边属性
            }
            is InheritsEdge -> {
                // 继承边属性
            }
        }
        
        writer.write("]->(target);\n")
    }
    
    /**
     * 生成图谱摘要报告
     */
    fun generateSummaryReport(codeGraph: CodeGraph, outputPath: String): ExportResult {
        return try {
            val startTime = System.currentTimeMillis()
            val outputFile = File(outputPath)
            outputFile.parentFile?.mkdirs()
            
            val writer = outputFile.bufferedWriter()
            
            writer.use { w ->
                w.write("# AutoCR 知识图谱分析报告\n\n")
                w.write("**项目名称**: ${project.name}\n")
                w.write("**生成时间**: ${LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))}\n\n")
                
                val allNodes = codeGraph.getAllNodes()
                val allEdges = codeGraph.getAllEdges()
                val classes = allNodes.filterIsInstance<ClassNode>()
                val methods = allNodes.filterIsInstance<MethodNode>()
                
                w.write("## 📊 统计概览\n\n")
                w.write("| 指标 | 数量 |\n")
                w.write("|------|------|\n")
                w.write("| 总节点数 | ${allNodes.size} |\n")
                w.write("| 总边数 | ${allEdges.size} |\n")
                w.write("| 类数量 | ${classes.size} |\n")
                w.write("| 方法数量 | ${methods.size} |\n\n")
                
                // 按包统计
                w.write("## 📦 包分布\n\n")
                val packageStats = classes.groupBy { it.packageName }
                w.write("| 包名 | 类数量 |\n")
                w.write("|------|--------|\n")
                packageStats.forEach { (pkg, classList) ->
                    w.write("| $pkg | ${classList.size} |\n")
                }
                w.write("\n")
                
                // 按块类型统计
                w.write("## 🏗️ 架构分布\n\n")
                val blockTypeStats = classes.groupBy { it.blockType }
                w.write("| 架构类型 | 类数量 |\n")
                w.write("|----------|--------|\n")
                blockTypeStats.forEach { (type, classList) ->
                    w.write("| ${type.name} | ${classList.size} |\n")
                }
                w.write("\n")
                
                // 复杂度分析
                w.write("## 🔍 复杂度分析\n\n")
                val complexities = methods.map { it.cyclomaticComplexity }
                if (complexities.isNotEmpty()) {
                    val avgComplexity = complexities.average()
                    val maxComplexity = complexities.maxOrNull() ?: 0
                    val highComplexityMethods = methods.filter { it.cyclomaticComplexity > 10 }
                    
                    w.write("- **平均复杂度**: %.2f\n".format(avgComplexity))
                    w.write("- **最高复杂度**: $maxComplexity\n")
                    w.write("- **高复杂度方法数**: ${highComplexityMethods.size}\n\n")
                    
                    if (highComplexityMethods.isNotEmpty()) {
                        w.write("### 🚨 高复杂度方法 (复杂度 > 10)\n\n")
                        w.write("| 方法名 | 复杂度 | 行数 | 文件 |\n")
                        w.write("|--------|--------|------|------|\n")
                        highComplexityMethods.sortedByDescending { it.cyclomaticComplexity }.take(10).forEach { method ->
                            w.write("| ${method.methodName} | ${method.cyclomaticComplexity} | ${method.linesOfCode} | ${method.filePath.substringAfterLast("/")} |\n")
                        }
                        w.write("\n")
                    }
                }
                
                // 关系统计
                w.write("## 🔗 关系分析\n\n")
                val edgeTypeStats = allEdges.groupBy { it.edgeType }
                w.write("| 关系类型 | 数量 |\n")
                w.write("|----------|------|\n")
                edgeTypeStats.forEach { (type, edgeList) ->
                    w.write("| ${type.name} | ${edgeList.size} |\n")
                }
                w.write("\n")
                
                // 热点分析
                w.write("## 🔥 热点分析\n\n")
                val methodCallCounts = mutableMapOf<String, Int>()
                allEdges.filterIsInstance<CallsEdge>().forEach { edge ->
                    methodCallCounts[edge.targetId] = methodCallCounts.getOrDefault(edge.targetId, 0) + 1
                }
                
                val topCalledMethods = methodCallCounts.entries
                    .sortedByDescending { it.value }
                    .take(10)
                    .mapNotNull { entry ->
                        methods.find { it.id == entry.key }?.let { it to entry.value }
                    }
                
                if (topCalledMethods.isNotEmpty()) {
                    w.write("### 📞 被调用最多的方法\n\n")
                    w.write("| 方法名 | 被调用次数 | 文件 |\n")
                    w.write("|--------|------------|------|\n")
                    topCalledMethods.forEach { (method, count) ->
                        w.write("| ${method.methodName} | $count | ${method.filePath.substringAfterLast("/")} |\n")
                    }
                    w.write("\n")
                }
            }
            
            val duration = System.currentTimeMillis() - startTime
            val allNodes = codeGraph.getAllNodes()
            val allEdges = codeGraph.getAllEdges()
            
            logger.info("Successfully generated summary report: $outputPath")
            
            ExportResult(
                success = true,
                filePath = outputPath,
                totalNodes = allNodes.size,
                totalEdges = allEdges.size,
                fileSize = outputFile.length(),
                duration = duration,
                message = "分析报告成功生成到 $outputPath"
            )
            
        } catch (e: Exception) {
            logger.error("Failed to generate summary report", e)
            ExportResult(
                success = false,
                filePath = outputPath,
                totalNodes = 0,
                totalEdges = 0,
                fileSize = 0,
                duration = 0,
                message = "报告生成失败: ${e.message}"
            )
        } finally {
            System.gc() // 清理内存
        }
    }
}

/**
 * 导出结果
 */
data class ExportResult(
    val success: Boolean,
    val filePath: String,
    val totalNodes: Int,
    val totalEdges: Int,
    val fileSize: Long,
    val duration: Long,
    val message: String
)