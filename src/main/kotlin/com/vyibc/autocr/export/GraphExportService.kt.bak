package com.vyibc.autocr.export

import com.intellij.openapi.components.Service
import com.intellij.openapi.components.service
import com.intellij.openapi.project.Project
import com.vyibc.autocr.graph.CodeGraph
import com.vyibc.autocr.model.*
import com.google.gson.stream.JsonWriter
import java.io.FileWriter
import java.io.BufferedWriter
import org.slf4j.LoggerFactory
import java.io.File
import java.time.Instant
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * å›¾è°±æ•°æ®å¯¼å‡ºæœåŠ¡ - ä¼˜åŒ–å†…å­˜ä½¿ç”¨ç‰ˆæœ¬
 * è´Ÿè´£å°†æœ¬åœ°å›¾è°±æ•°æ®å¯¼å‡ºä¸ºå„ç§æ ¼å¼æ–‡ä»¶ï¼Œä½¿ç”¨æµå¼å¤„ç†é¿å…å†…å­˜æº¢å‡º
 */
@Service(Service.Level.PROJECT)
class GraphExportService(private val project: Project) {
    private val logger = LoggerFactory.getLogger(GraphExportService::class.java)
    
    // å†…å­˜ä¼˜åŒ–é…ç½®
    companion object {
        private const val NODE_BATCH_SIZE = 50 // æ¯æ‰¹å¤„ç†çš„èŠ‚ç‚¹æ•°é‡
        private const val EDGE_BATCH_SIZE = 100 // æ¯æ‰¹å¤„ç†çš„è¾¹æ•°é‡
        private const val MEMORY_CHECK_INTERVAL = 5 // æ¯å¤„ç†å¤šå°‘æ‰¹æ£€æŸ¥ä¸€æ¬¡å†…å­˜
        private const val MIN_FREE_MEMORY_MB = 50 // æœ€å°å‰©ä½™å†…å­˜(MB)
        private const val FORCE_GC_THRESHOLD = 70 // å¼ºåˆ¶GCçš„å†…å­˜ä½¿ç”¨ç‡é˜ˆå€¼(%)
        
        fun getInstance(project: Project): GraphExportService {
            return project.service()
        }
    }
    
    /**
     * å¯¼å‡ºå›¾è°±æ•°æ®ä¸ºJSONæ ¼å¼ - ä½¿ç”¨æµå¼å†™å…¥ä¼˜åŒ–å†…å­˜
     */
    fun exportToJson(codeGraph: CodeGraph, outputPath: String): ExportResult {
        return try {
            val startTime = System.currentTimeMillis()
            
            val outputFile = File(outputPath)
            outputFile.parentFile?.mkdirs()
            
            FileWriter(outputFile).use { fileWriter ->
                JsonWriter(fileWriter).use { writer ->
                    writer.setIndent("  ") // è®¾ç½®ç¼©è¿›ç¾åŒ–è¾“å‡º
                    
                    writer.beginObject() // å¼€å§‹æ ¹å¯¹è±¡
                    
                    // å†™å…¥å…ƒæ•°æ®
                    writeMetadata(writer)
                    
                    // è·å–å¹¶å†™å…¥ç»Ÿè®¡ä¿¡æ¯
                    val allNodes = codeGraph.getAllNodes()
                    val allEdges = codeGraph.getAllEdges()
                    writeStatistics(writer, allNodes, allEdges)
                    
                    // åˆ†æ‰¹å†™å…¥èŠ‚ç‚¹æ•°æ®
                    writeNodesInBatches(writer, allNodes)
                    
                    // åˆ†æ‰¹å†™å…¥è¾¹æ•°æ®
                    writeEdgesInBatches(writer, allEdges)
                    
                    writer.endObject() // ç»“æŸæ ¹å¯¹è±¡
                }
            }
            
            val duration = System.currentTimeMillis() - startTime
            val allNodes = codeGraph.getAllNodes()
            val allEdges = codeGraph.getAllEdges()
            
            logger.info("Successfully exported graph data to: $outputPath")
            logger.info("Export statistics: {} nodes, {} edges, duration: {}ms", 
                allNodes.size, allEdges.size, duration)
            
            ExportResult(
                success = true,
                filePath = outputPath,
                totalNodes = allNodes.size,
                totalEdges = allEdges.size,
                fileSize = outputFile.length(),
                duration = duration,
                message = "å›¾è°±æ•°æ®æˆåŠŸå¯¼å‡ºåˆ° $outputPath"
            )
            
        } catch (e: Exception) {
            logger.error("Failed to export graph data to JSON", e)
            ExportResult(
                success = false,
                filePath = outputPath,
                totalNodes = 0,
                totalEdges = 0,
                fileSize = 0,
                duration = 0,
                message = "å¯¼å‡ºå¤±è´¥: ${e.message}"
            )
        } finally {
            // å¼ºåˆ¶è¿›è¡Œåƒåœ¾å›æ”¶ä»¥é‡Šæ”¾å†…å­˜
            System.gc()
        }
    }
    
    /**
     * å†™å…¥å…ƒæ•°æ®
     */
    private fun writeMetadata(writer: JsonWriter) {
        writer.name("metadata")
        writer.beginObject()
        writer.name("projectName").value(project.name)
        writer.name("exportTime").value(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))
        writer.name("exportVersion").value("1.0")
        writer.endObject()
    }
    
    /**
     * å†™å…¥ç»Ÿè®¡ä¿¡æ¯
     */
    private fun writeStatistics(writer: JsonWriter, allNodes: List<Node>, allEdges: List<Edge>) {
        val classes = allNodes.filterIsInstance<ClassNode>()
        val methods = allNodes.filterIsInstance<MethodNode>()
        
        writer.name("statistics")
        writer.beginObject()
        
        writer.name("totalNodes").value(allNodes.size)
        writer.name("totalEdges").value(allEdges.size)
        writer.name("totalClasses").value(classes.size)
        writer.name("totalMethods").value(methods.size)
        
        // è¾¹ç±»å‹åˆ†å¸ƒ
        writer.name("edgeTypeDistribution")
        writer.beginObject()
        allEdges.groupBy { it.edgeType }.forEach { (type, edges) ->
            writer.name(type.name).value(edges.size)
        }
        writer.endObject()
        
        // ç±»å—ç±»å‹åˆ†å¸ƒ
        writer.name("classBlockTypeDistribution")
        writer.beginObject()
        classes.groupBy { it.blockType }.forEach { (type, classList) ->
            writer.name(type.name).value(classList.size)
        }
        writer.endObject()
        
        // æ–¹æ³•å—ç±»å‹åˆ†å¸ƒ
        writer.name("methodBlockTypeDistribution")
        writer.beginObject()
        methods.groupBy { it.blockType }.forEach { (type, methodList) ->
            writer.name(type.name).value(methodList.size)
        }
        writer.endObject()
        
        writer.endObject()
    }
    
    /**
     * åˆ†æ‰¹å†™å…¥èŠ‚ç‚¹æ•°æ®
     */
    private fun writeNodesInBatches(writer: JsonWriter, allNodes: List<Node>) {
        writer.name("nodes")
        writer.beginArray()
        
        val classes = allNodes.filterIsInstance<ClassNode>()
        val methods = allNodes.filterIsInstance<MethodNode>()
        
        // åˆ†æ‰¹å¤„ç†ç±»èŠ‚ç‚¹
        var batchCount = 0
        classes.chunked(NODE_BATCH_SIZE).forEach { batch ->
            batch.forEach { classNode ->
                writeClassNode(writer, classNode)
            }
            
            // å®šæœŸæ£€æŸ¥å†…å­˜å¹¶æ¸…ç†
            if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                checkMemoryAndGC()
            }
        }
        
        // åˆ†æ‰¹å¤„ç†æ–¹æ³•èŠ‚ç‚¹
        methods.chunked(NODE_BATCH_SIZE).forEach { batch ->
            batch.forEach { methodNode ->
                writeMethodNode(writer, methodNode)
            }
            
            // å®šæœŸæ£€æŸ¥å†…å­˜å¹¶æ¸…ç†
            if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                checkMemoryAndGC()
            }
        }
        
        writer.endArray()
    }
    
    /**
     * å†™å…¥ç±»èŠ‚ç‚¹
     */
    private fun writeClassNode(writer: JsonWriter, classNode: ClassNode) {
        writer.beginObject()
        writer.name("id").value(classNode.id)
        writer.name("type").value("class")
        writer.name("className").value(classNode.className)
        writer.name("packageName").value(classNode.packageName)
        writer.name("blockType").value(classNode.blockType.name)
        writer.name("isInterface").value(classNode.isInterface)
        writer.name("isAbstract").value(classNode.isAbstract)
        writer.name("filePath").value(classNode.filePath)
        
        if (classNode.superClass != null) {
            writer.name("superClass").value(classNode.superClass)
        }
        
        if (classNode.implementedInterfaces.isNotEmpty()) {
            writer.name("implementedInterfaces")
            writer.beginArray()
            classNode.implementedInterfaces.forEach { writer.value(it) }
            writer.endArray()
        }
        
        if (classNode.annotations.isNotEmpty()) {
            writer.name("annotations")
            writer.beginArray()
            classNode.annotations.forEach { writer.value(it) }
            writer.endArray()
        }
        
        writer.endObject()
    }
    
    /**
     * å†™å…¥æ–¹æ³•èŠ‚ç‚¹
     */
    private fun writeMethodNode(writer: JsonWriter, methodNode: MethodNode) {
        writer.beginObject()
        writer.name("id").value(methodNode.id)
        writer.name("type").value("method")
        writer.name("methodName").value(methodNode.methodName)
        writer.name("signature").value(methodNode.signature)
        writer.name("returnType").value(methodNode.returnType)
        writer.name("blockType").value(methodNode.blockType.name)
        writer.name("filePath").value(methodNode.filePath)
        writer.name("lineNumber").value(methodNode.lineNumber)
        writer.name("startLineNumber").value(methodNode.startLineNumber)
        writer.name("endLineNumber").value(methodNode.endLineNumber)
        writer.name("cyclomaticComplexity").value(methodNode.cyclomaticComplexity)
        writer.name("linesOfCode").value(methodNode.linesOfCode)
        writer.name("lastModified").value(methodNode.lastModified.toString())
        
        if (methodNode.paramTypes.isNotEmpty()) {
            writer.name("paramTypes")
            writer.beginArray()
            methodNode.paramTypes.forEach { writer.value(it) }
            writer.endArray()
        }
        
        if (methodNode.annotations.isNotEmpty()) {
            writer.name("annotations")
            writer.beginArray()
            methodNode.annotations.forEach { writer.value(it) }
            writer.endArray()
        }
        
        writer.endObject()
    }
    
    /**
     * åˆ†æ‰¹å†™å…¥è¾¹æ•°æ®
     */
    private fun writeEdgesInBatches(writer: JsonWriter, allEdges: List<Edge>) {
        writer.name("edges")
        writer.beginArray()
        
        var batchCount = 0
        allEdges.chunked(EDGE_BATCH_SIZE).forEach { batch ->
            batch.forEach { edge ->
                writeEdge(writer, edge)
            }
            
            // å®šæœŸæ£€æŸ¥å†…å­˜å¹¶æ¸…ç†
            if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                checkMemoryAndGC()
            }
        }
        
        writer.endArray()
    }
    
    /**
     * å†™å…¥è¾¹æ•°æ®
     */
    private fun writeEdge(writer: JsonWriter, edge: Edge) {
        writer.beginObject()
        writer.name("id").value(edge.id)
        writer.name("sourceId").value(edge.sourceId)
        writer.name("targetId").value(edge.targetId)
        writer.name("edgeType").value(edge.edgeType.name)
        
        // æ ¹æ®è¾¹ç±»å‹æ·»åŠ ç‰¹å®šå±æ€§
        when (edge) {
            is CallsEdge -> {
                writer.name("callType").value(edge.callType)
                writer.name("lineNumber").value(edge.lineNumber)
            }
            is ContainsEdge -> {
                // åŒ…å«è¾¹çš„ç‰¹å®šå±æ€§
            }
            is DataFlowEdge -> {
                // æ•°æ®æµè¾¹çš„ç‰¹å®šå±æ€§
            }
            is ImplementsEdge -> {
                // å®ç°è¾¹çš„ç‰¹å®šå±æ€§
            }
            is InheritsEdge -> {
                // ç»§æ‰¿è¾¹çš„ç‰¹å®šå±æ€§
            }
        }
        
        writer.endObject()
    }
    
    /**
     * æ£€æŸ¥å†…å­˜å¹¶æ‰§è¡Œåƒåœ¾å›æ”¶
     */
    private fun checkMemoryAndGC() {
        val runtime = Runtime.getRuntime()
        val maxMemory = runtime.maxMemory()
        val totalMemory = runtime.totalMemory()
        val freeMemory = runtime.freeMemory()
        val usedMemory = totalMemory - freeMemory
        val heapUsagePercent = (usedMemory * 100) / maxMemory
        
        if (heapUsagePercent >= FORCE_GC_THRESHOLD) {
            logger.debug("High memory usage detected ({}%), performing GC", heapUsagePercent)
            System.gc()
            Thread.sleep(100) // ç»™GCä¸€ç‚¹æ—¶é—´
        }
    }
    
    /**
     * å¯¼å‡ºå›¾è°±æ•°æ®ä¸ºCypheræ ¼å¼ï¼ˆç”¨äºNeo4jå¯¼å…¥ï¼‰- ä½¿ç”¨æµå¼å†™å…¥ä¼˜åŒ–å†…å­˜
     */
    fun exportToCypher(codeGraph: CodeGraph, outputPath: String): ExportResult {
        return try {
            val startTime = System.currentTimeMillis()
            val outputFile = File(outputPath)
            outputFile.parentFile?.mkdirs()
            
            val writer = outputFile.bufferedWriter()
            
            writer.use { w ->
                // å†™å…¥æ–‡ä»¶å¤´
                w.write("// AutoCR çŸ¥è¯†å›¾è°± Cypher å¯¼å‡ºæ–‡ä»¶\n")
                w.write("// é¡¹ç›®: ${project.name}\n")
                w.write("// å¯¼å‡ºæ—¶é—´: ${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}\n\n")
                
                // æ¸…ç©ºæ•°æ®åº“
                w.write("// æ¸…ç©ºç°æœ‰æ•°æ®\n")
                w.write("MATCH (n) DETACH DELETE n;\n\n")
                
                val allNodes = codeGraph.getAllNodes()
                val allEdges = codeGraph.getAllEdges()
                
                // åˆ†æ‰¹å†™å…¥ç±»èŠ‚ç‚¹
                w.write("// åˆ›å»ºç±»èŠ‚ç‚¹\n")
                val classes = allNodes.filterIsInstance<ClassNode>()
                var batchCount = 0
                classes.chunked(NODE_BATCH_SIZE).forEach { batch ->
                    batch.forEach { classNode ->
                        writeClassNodeCypher(w, classNode)
                    }
                    w.flush() // å®šæœŸåˆ·æ–°ç¼“å†²åŒº
                    
                    if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                        checkMemoryAndGC()
                    }
                }
                
                // åˆ†æ‰¹å†™å…¥æ–¹æ³•èŠ‚ç‚¹
                w.write("\n// åˆ›å»ºæ–¹æ³•èŠ‚ç‚¹\n")
                val methods = allNodes.filterIsInstance<MethodNode>()
                methods.chunked(NODE_BATCH_SIZE).forEach { batch ->
                    batch.forEach { methodNode ->
                        writeMethodNodeCypher(w, methodNode)
                    }
                    w.flush() // å®šæœŸåˆ·æ–°ç¼“å†²åŒº
                    
                    if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                        checkMemoryAndGC()
                    }
                }
                
                // åˆ†æ‰¹å†™å…¥å…³ç³»
                w.write("\n// åˆ›å»ºå…³ç³»\n")
                allEdges.chunked(EDGE_BATCH_SIZE).forEach { batch ->
                    batch.forEach { edge ->
                        writeEdgeCypher(w, edge)
                    }
                    w.flush() // å®šæœŸåˆ·æ–°ç¼“å†²åŒº
                    
                    if (++batchCount % MEMORY_CHECK_INTERVAL == 0) {
                        checkMemoryAndGC()
                    }
                }
                
                // å†™å…¥ç´¢å¼•åˆ›å»ºè¯­å¥
                w.write("\n// åˆ›å»ºç´¢å¼•\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (c:Class) ON (c.id);\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (m:Method) ON (m.id);\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (c:Class) ON (c.packageName);\n")
                w.write("CREATE INDEX IF NOT EXISTS FOR (m:Method) ON (m.methodName);\n")
            }
            
            val duration = System.currentTimeMillis() - startTime
            val allNodes = codeGraph.getAllNodes()
            val allEdges = codeGraph.getAllEdges()
            
            logger.info("Successfully exported graph data to Cypher format: $outputPath")
            
            ExportResult(
                success = true,
                filePath = outputPath,
                totalNodes = allNodes.size,
                totalEdges = allEdges.size,
                fileSize = outputFile.length(),
                duration = duration,
                message = "Cypherè„šæœ¬æˆåŠŸå¯¼å‡ºåˆ° $outputPath"
            )
            
        } catch (e: Exception) {
            logger.error("Failed to export graph data to Cypher format", e)
            ExportResult(
                success = false,
                filePath = outputPath,
                totalNodes = 0,
                totalEdges = 0,
                fileSize = 0,
                duration = 0,
                message = "Cypherå¯¼å‡ºå¤±è´¥: ${e.message}"
            )
        } finally {
            System.gc() // æ¸…ç†å†…å­˜
        }
    }
    
    /**
     * å†™å…¥ç±»èŠ‚ç‚¹çš„Cypherè¯­å¥
     */
    private fun writeClassNodeCypher(writer: BufferedWriter, classNode: ClassNode) {
        writer.write("CREATE (c:Class {\n")
        writer.write("  id: '${classNode.id}',\n")
        writer.write("  className: '${classNode.className}',\n")
        writer.write("  packageName: '${classNode.packageName}',\n")
        writer.write("  blockType: '${classNode.blockType.name}',\n")
        writer.write("  isInterface: ${classNode.isInterface},\n")
        writer.write("  isAbstract: ${classNode.isAbstract},\n")
        writer.write("  filePath: '${classNode.filePath}'\n")
        writer.write("});\n")
    }
    
    /**
     * å†™å…¥æ–¹æ³•èŠ‚ç‚¹çš„Cypherè¯­å¥
     */
    private fun writeMethodNodeCypher(writer: BufferedWriter, methodNode: MethodNode) {
        writer.write("CREATE (m:Method {\n")
        writer.write("  id: '${methodNode.id}',\n")
        writer.write("  methodName: '${methodNode.methodName}',\n")
        writer.write("  signature: '${methodNode.signature}',\n")
        writer.write("  returnType: '${methodNode.returnType}',\n")
        writer.write("  blockType: '${methodNode.blockType.name}',\n")
        writer.write("  filePath: '${methodNode.filePath}',\n")
        writer.write("  lineNumber: ${methodNode.lineNumber},\n")
        writer.write("  cyclomaticComplexity: ${methodNode.cyclomaticComplexity},\n")
        writer.write("  linesOfCode: ${methodNode.linesOfCode}\n")
        writer.write("});\n")
    }
    
    /**
     * å†™å…¥è¾¹çš„Cypherè¯­å¥
     */
    private fun writeEdgeCypher(writer: BufferedWriter, edge: Edge) {
        val relationshipType = when (edge.edgeType) {
            EdgeType.CALLS -> "CALLS"
            EdgeType.INHERITS -> "INHERITS"
            EdgeType.IMPLEMENTS -> "IMPLEMENTS"
            EdgeType.CONTAINS -> "CONTAINS"
            EdgeType.DATA_FLOW -> "DATA_FLOW"
        }
        
        writer.write("MATCH (source {id: '${edge.sourceId}'}), (target {id: '${edge.targetId}'})\n")
        writer.write("CREATE (source)-[:$relationshipType")
        
        // æ·»åŠ å…³ç³»å±æ€§
        when (edge) {
            is CallsEdge -> {
                writer.write(" {callType: '${edge.callType}', lineNumber: ${edge.lineNumber}}")
            }
            is ContainsEdge -> {
                // åŒ…å«è¾¹å±æ€§
            }
            is DataFlowEdge -> {
                // æ•°æ®æµè¾¹å±æ€§
            }
            is ImplementsEdge -> {
                // å®ç°è¾¹å±æ€§
            }
            is InheritsEdge -> {
                // ç»§æ‰¿è¾¹å±æ€§
            }
        }
        
        writer.write("]->(target);\n")
    }
    
    /**
     * ç”Ÿæˆå›¾è°±æ‘˜è¦æŠ¥å‘Š
     */
    fun generateSummaryReport(codeGraph: CodeGraph, outputPath: String): ExportResult {
        return try {
            val startTime = System.currentTimeMillis()
            val outputFile = File(outputPath)
            outputFile.parentFile?.mkdirs()
            
            val writer = outputFile.bufferedWriter()
            
            writer.use { w ->
                w.write("# AutoCR çŸ¥è¯†å›¾è°±åˆ†ææŠ¥å‘Š\n\n")
                w.write("**é¡¹ç›®åç§°**: ${project.name}\n")
                w.write("**ç”Ÿæˆæ—¶é—´**: ${LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))}\n\n")
                
                val allNodes = codeGraph.getAllNodes()
                val allEdges = codeGraph.getAllEdges()
                val classes = allNodes.filterIsInstance<ClassNode>()
                val methods = allNodes.filterIsInstance<MethodNode>()
                
                w.write("## ğŸ“Š ç»Ÿè®¡æ¦‚è§ˆ\n\n")
                w.write("| æŒ‡æ ‡ | æ•°é‡ |\n")
                w.write("|------|------|\n")
                w.write("| æ€»èŠ‚ç‚¹æ•° | ${allNodes.size} |\n")
                w.write("| æ€»è¾¹æ•° | ${allEdges.size} |\n")
                w.write("| ç±»æ•°é‡ | ${classes.size} |\n")
                w.write("| æ–¹æ³•æ•°é‡ | ${methods.size} |\n\n")
                
                // æŒ‰åŒ…ç»Ÿè®¡
                w.write("## ğŸ“¦ åŒ…åˆ†å¸ƒ\n\n")
                val packageStats = classes.groupBy { it.packageName }
                w.write("| åŒ…å | ç±»æ•°é‡ |\n")
                w.write("|------|--------|\n")
                packageStats.forEach { (pkg, classList) ->
                    w.write("| $pkg | ${classList.size} |\n")
                }
                w.write("\n")
                
                // æŒ‰å—ç±»å‹ç»Ÿè®¡
                w.write("## ğŸ—ï¸ æ¶æ„åˆ†å¸ƒ\n\n")
                val blockTypeStats = classes.groupBy { it.blockType }
                w.write("| æ¶æ„ç±»å‹ | ç±»æ•°é‡ |\n")
                w.write("|----------|--------|\n")
                blockTypeStats.forEach { (type, classList) ->
                    w.write("| ${type.name} | ${classList.size} |\n")
                }
                w.write("\n")
                
                // å¤æ‚åº¦åˆ†æ
                w.write("## ğŸ” å¤æ‚åº¦åˆ†æ\n\n")
                val complexities = methods.map { it.cyclomaticComplexity }
                if (complexities.isNotEmpty()) {
                    val avgComplexity = complexities.average()
                    val maxComplexity = complexities.maxOrNull() ?: 0
                    val highComplexityMethods = methods.filter { it.cyclomaticComplexity > 10 }
                    
                    w.write("- **å¹³å‡å¤æ‚åº¦**: %.2f\n".format(avgComplexity))
                    w.write("- **æœ€é«˜å¤æ‚åº¦**: $maxComplexity\n")
                    w.write("- **é«˜å¤æ‚åº¦æ–¹æ³•æ•°**: ${highComplexityMethods.size}\n\n")
                    
                    if (highComplexityMethods.isNotEmpty()) {
                        w.write("### ğŸš¨ é«˜å¤æ‚åº¦æ–¹æ³• (å¤æ‚åº¦ > 10)\n\n")
                        w.write("| æ–¹æ³•å | å¤æ‚åº¦ | è¡Œæ•° | æ–‡ä»¶ |\n")
                        w.write("|--------|--------|------|------|\n")
                        highComplexityMethods.sortedByDescending { it.cyclomaticComplexity }.take(10).forEach { method ->
                            w.write("| ${method.methodName} | ${method.cyclomaticComplexity} | ${method.linesOfCode} | ${method.filePath.substringAfterLast("/")} |\n")
                        }
                        w.write("\n")
                    }
                }
                
                // å…³ç³»ç»Ÿè®¡
                w.write("## ğŸ”— å…³ç³»åˆ†æ\n\n")
                val edgeTypeStats = allEdges.groupBy { it.edgeType }
                w.write("| å…³ç³»ç±»å‹ | æ•°é‡ |\n")
                w.write("|----------|------|\n")
                edgeTypeStats.forEach { (type, edgeList) ->
                    w.write("| ${type.name} | ${edgeList.size} |\n")
                }
                w.write("\n")
                
                // çƒ­ç‚¹åˆ†æ
                w.write("## ğŸ”¥ çƒ­ç‚¹åˆ†æ\n\n")
                val methodCallCounts = mutableMapOf<String, Int>()
                allEdges.filterIsInstance<CallsEdge>().forEach { edge ->
                    methodCallCounts[edge.targetId] = methodCallCounts.getOrDefault(edge.targetId, 0) + 1
                }
                
                val topCalledMethods = methodCallCounts.entries
                    .sortedByDescending { it.value }
                    .take(10)
                    .mapNotNull { entry ->
                        methods.find { it.id == entry.key }?.let { it to entry.value }
                    }
                
                if (topCalledMethods.isNotEmpty()) {
                    w.write("### ğŸ“ è¢«è°ƒç”¨æœ€å¤šçš„æ–¹æ³•\n\n")
                    w.write("| æ–¹æ³•å | è¢«è°ƒç”¨æ¬¡æ•° | æ–‡ä»¶ |\n")
                    w.write("|--------|------------|------|\n")
                    topCalledMethods.forEach { (method, count) ->
                        w.write("| ${method.methodName} | $count | ${method.filePath.substringAfterLast("/")} |\n")
                    }
                    w.write("\n")
                }
            }
            
            val duration = System.currentTimeMillis() - startTime
            val allNodes = codeGraph.getAllNodes()
            val allEdges = codeGraph.getAllEdges()
            
            logger.info("Successfully generated summary report: $outputPath")
            
            ExportResult(
                success = true,
                filePath = outputPath,
                totalNodes = allNodes.size,
                totalEdges = allEdges.size,
                fileSize = outputFile.length(),
                duration = duration,
                message = "åˆ†ææŠ¥å‘ŠæˆåŠŸç”Ÿæˆåˆ° $outputPath"
            )
            
        } catch (e: Exception) {
            logger.error("Failed to generate summary report", e)
            ExportResult(
                success = false,
                filePath = outputPath,
                totalNodes = 0,
                totalEdges = 0,
                fileSize = 0,
                duration = 0,
                message = "æŠ¥å‘Šç”Ÿæˆå¤±è´¥: ${e.message}"
            )
        } finally {
            System.gc() // æ¸…ç†å†…å­˜
        }
    }
}

/**
 * å¯¼å‡ºç»“æœ
 */
data class ExportResult(
    val success: Boolean,
    val filePath: String,
    val totalNodes: Int,
    val totalEdges: Int,
    val fileSize: Long,
    val duration: Long,
    val message: String
)