# AutoCR 知识图谱初步分析报告

## 📊 项目概览

**项目名称**: AutoCR - AI Code Review  
**项目类型**: IntelliJ IDEA 插件  
**开发语言**: Kotlin  
**当前版本**: 1.0-SNAPSHOT  
**开发阶段**: Phase 1 完成（分阶段索引和图谱导出功能）

## 🏗️ 知识图谱架构

### 1. 区块（Block）类型定义

AutoCR 使用 `BlockType` 枚举来对代码进行架构层级分类，包含9种区块类型：

| 区块类型 | 说明 | 用途 |
|---------|------|------|
| **CONTROLLER** | 控制器层 | 处理用户请求和响应 |
| **SERVICE** | 服务层 | 业务逻辑处理 |
| **MAPPER** | 映射层 | 数据访问对象映射 |
| **REPOSITORY** | 数据仓库层 | 数据持久化操作 |
| **UTIL** | 工具类 | 通用工具方法 |

[//]: # (| **CONFIG** | 配置类 | 系统配置管理 |)

[//]: # (| **ENTITY** | 实体类 | 数据库实体模型 |)

[//]: # (| **DTO** | 数据传输对象 | 层间数据传输 |)

### 2. 节点（Node）类型定义

知识图谱包含两种主要节点类型：

#### 2.1 方法节点（MethodNode）
- **节点ID格式**: `{packageName}.{className}#{methodName}({paramTypes})`
- **核心属性**:
  - 方法签名信息（名称、返回类型、参数类型）
  - 所属区块类型（BlockType）
  - 代码位置信息（文件路径、行号范围）
  - 性能指标（圈复杂度、代码行数、出入度）
  - 风险评分（预计算的风险分数）
  - 测试覆盖（是否有测试）

#### 2.2 类节点（ClassNode）
- **节点ID格式**: `{packageName}.{className}`
- **核心属性**:
  - 类基本信息（名称、包名、类型）
  - 继承关系（父类、实现接口）
  - 代码度量（方法数、字段数、内聚度、耦合度）
  - 设计模式（识别的设计模式列表）

### 3. 链路（Edge）类型定义

知识图谱包含5种关系类型：

| 边类型 | 说明 | 源节点 → 目标节点 |
|--------|------|-------------------|
| **CALLS** | 方法调用关系 | 调用方法 → 被调用方法 |
| **IMPLEMENTS** | 接口实现关系 | 实现类 → 接口 |
| **INHERITS** | 继承关系 | 子类 → 父类 |
| **DATA_FLOW** | 数据流关系 | 数据源方法 → 数据目标方法 |
| **CONTAINS** | 包含关系 | 类 → 方法 |

#### 3.1 调用边（CallsEdge）详细属性
- 调用类型（直接调用、接口调用、反射调用、Lambda调用）
- 调用位置（行号）
- 调用频率（静态分析估算）
- 条件调用标记
- 风险权重和意图权重
- MR变更标记（新增/修改）

#### 3.2 数据流边（DataFlowEdge）详细属性
- 数据类型
- 流向类型（参数传递、返回值、字段访问）
- 敏感数据标记

## 📈 当前开发进度分析

### 已完成功能（✅）

1. **核心数据模型**
   - 完整的节点和边数据结构定义
   - 支持V5.1版本的所有扩展字段
   - 类型安全的Kotlin实现

2. **图数据库架构**
   - 双图谱架构设计（本地TinkerGraph + Neo4j可视化）
   - CodeGraph接口定义了完整的图操作API
   - 支持图的持久化和加载

3. **项目索引系统**
   - 自动项目扫描和索引
   - 文件变更监听和增量更新
   - 安全的错误处理机制

4. **数据导出功能**
   - JSON格式完整数据导出
   - Cypher脚本生成（用于Neo4j导入）
   - Markdown格式分析报告

5. **缓存系统**
   - 三级缓存架构（内存、磁盘、AI结果）
   - 智能缓存管理和失效策略

### 待完成功能（🔄）

根据代码中的TODO注释，以下功能尚未完全实现：

1. **Git集成增强**
   - 从代码差异中提取具体的方法变更
   - 获取当前Git分支信息
   - 获取最近commit信息

2. **代码分析增强**
   - 重复代码检测
   - 命名质量分析
   - 架构层违规检测
   - 循环依赖检测

3. **图序列化**
   - SimpleCodeGraph的序列化/反序列化实现

4. **配置管理**
   - 自定义提示词模板的加载和保存

## 🔍 知识图谱统计预期

基于代码结构分析，索引完成后预计会生成：

### 节点统计
- **类节点数量**: 约45个（基于src目录结构）
- **方法节点数量**: 约200-300个（估算每个类平均5-7个方法）
- **总节点数**: 约245-345个

### 边统计
- **CALLS关系**: 预计最多，约100-200条
- **CONTAINS关系**: 等于方法节点数量
- **IMPLEMENTS关系**: 约10-20条
- **INHERITS关系**: 约5-10条
- **DATA_FLOW关系**: 约20-50条
- **总边数**: 约350-550条

### 区块分布预期
- **SERVICE**: 核心业务逻辑服务（约10个）
- **UI**: 用户界面组件（约5个）
- **MODEL**: 数据模型类（约8个）
- **UTIL**: 工具类（约5个）
- **CONFIG**: 配置类（约3个）
- **其他**: 约14个

## 🎯 关键路径分析

### 核心执行流程
1. **插件启动** → AutoCRProjectStartupActivity
2. **项目索引** → ProjectIndexingService
3. **代码分析** → PSIService + GitDiffAnalyzer
4. **图谱构建** → SimpleCodeGraph
5. **权重计算** → IntentWeightCalculator + RiskWeightCalculator
6. **AI分析** → MultiAIAdapterService
7. **结果展示** → CodeReviewReportWindow

### 关键依赖关系
- 所有服务依赖于 `Project` 实例
- 图谱构建依赖于 PSI 解析结果
- AI分析依赖于预处理器的权重计算
- 数据导出依赖于图谱构建完成

## 💡 使用建议

1. **首次使用流程**
   - 安装插件后等待自动索引完成
   - 查看导出的JSON文件了解项目结构
   - 配置所需的AI供应商
   - 使用Cypher脚本在Neo4j中可视化

2. **图谱分析重点**
   - 关注高出入度的方法节点（核心方法）
   - 检查跨层调用关系（架构违规）
   - 分析循环依赖（如果存在）
   - 识别孤立节点（未使用的代码）

3. **性能优化建议**
   - 利用缓存系统减少重复计算
   - 增量更新而非全量重建
   - 异步处理大型项目索引

## 📝 总结

AutoCR 插件实现了一个完整的代码知识图谱系统，通过精心设计的节点和边模型，能够全面捕获项目的代码结构和依赖关系。当前已完成核心架构和基础功能，正在逐步完善具体的分析能力。知识图谱的设计充分考虑了性能、可扩展性和实用性，为后续的AI代码评审功能奠定了坚实基础。